<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Pixel Racer</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
    body { overflow: hidden; background: #000; font-family: 'Press Start 2P', cursive; touch-action: none; image-rendering: pixelated; }
    canvas { display: block; width: 100vw; height: 100vh; }

    #ui { position: absolute; top: 10px; left: 10px; right: 10px; display: flex; justify-content: space-between; color: #fff; font-size: clamp(12px, 3vw, 16px); text-shadow: 2px 2px 0 #000; pointer-events: none; z-index: 10; }
    #dollars, #km { background: rgba(0,0,0,0.7); padding: 10px 16px; border: 3px solid #fff; border-radius: 4px; text-align: center; min-width: 20%; }

    #buttons { position: absolute; bottom: 20px; left: 10px; right: 10px; display: flex; gap: 20px; z-index: 20; }
    .btn { flex: 1; padding: clamp(12px, 5vw, 18px) 0; font-family: 'Press Start 2P', cursive; font-size: clamp(12px, 4vw, 16px); border: 4px solid #fff; cursor: pointer; text-align: center; box-shadow: 4px 4px 0 #000; transition: all 0.1s; }
    #startBtn { background: #c00; color: #fff; }
    #startBtn.disabled { background: #600; color: #aaa; pointer-events: none; box-shadow: 2px 2px 0 #000; }
    #cashoutBtn { background: #0c0; color: #fff; }

    #modal { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #111; border: 6px solid #fff; padding: clamp(20px, 8vw, 40px); text-align: center; color: #fff; font-size: clamp(14px, 4vw, 18px); box-shadow: 8px 8px 0 #000; z-index: 100; display: none; max-width: 95%; border-radius: 8px; }
    #modal h2 { margin-bottom: 20px; color: #f00; font-size: 1.2em; }
    #modal p { margin: 15px 0; line-height: 1.4; }
    #lostAmount { color: #f66; font-size: 1.4em; margin: 10px 0; }
    #okBtn { margin-top: 25px; padding: 14px 40px; background: #ff0; color: #000; border: 4px solid #fff; font-family: 'Press Start 2P', cursive; font-size: clamp(12px, 4vw, 16px); cursor: pointer; box-shadow: 4px 4px 0 #000; }
  </style>
</head>
<body>
  <div id="ui">
    <div id="dollars">$0</div>
    <div id="km">0.0 km</div>
  </div>

  <div id="buttons">
    <div id="startBtn" class="btn">START</div>
    <div id="cashoutBtn" class="btn">CASHOUT</div>
  </div>

  <div id="modal">
    <h2>CRASH!</h2>
    <p id="resultText">You lost:</p>
    <p id="lostAmount"></p>
    <p id="distText"></p>
    <div id="okBtn">OK</div>
  </div>

  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const dollarsEl = document.getElementById('dollars');
    const kmEl = document.getElementById('km');
    const startBtn = document.getElementById('startBtn');
    const cashoutBtn = document.getElementById('cashoutBtn');
    const modal = document.getElementById('modal');
    const resultText = document.getElementById('resultText');
    const lostAmountEl = document.getElementById('lostAmount');
    const distText = document.getElementById('distText');
    const okBtn = document.getElementById('okBtn');

    // === Global vars ===
    let roadX, roadWidth, laneWidth, playerWidth, playerHeight;
    const lanes = 4;
    let player, enemies, coins, roadOffset, dollars, distance, gameActive = false;
    let baseRoadSpeed = 12; // x2 faster
    let roadSpeed = baseRoadSpeed;
    let spawnTimer = 0;
    const spawnRate = 60; // faster spawn
    let coinSpawnTimer = 0;
    const coinSpawnRate = 400; // ~5-7 per km
    let dollarAcc = 0;
    const dollarRate = 20 / (60 * 5); // faster dollars

    // === Resize ===
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      roadWidth = canvas.width * 0.9;
      roadX = (canvas.width - roadWidth) / 2;
      laneWidth = roadWidth / lanes;

      playerWidth = laneWidth * 0.65;
      playerHeight = playerWidth * 2.2; // TALLER player

      if (player) {
        player.width = playerWidth;
        player.height = playerHeight;
        player.x = getLaneX(player.targetLane);
        player.y = canvas.height - playerHeight - 120; // HIGHER UP
      }
    }

    // === Init ===
    resize();
    window.addEventListener('resize', resize);

    function initGame() {
      resetGame();
      draw();
    }

    function resetGame() {
      player = {
        lane: 1,
        targetLane: 1,
        x: getLaneX(1),
        y: canvas.height - playerHeight - 120,
        width: playerWidth,
        height: playerHeight
      };

      enemies = [];
      coins = [];
      roadOffset = 0;
      dollars = 0;
      distance = 0;
      gameActive = false;
      spawnTimer = 0;
      coinSpawnTimer = 0;
      dollarAcc = 0;
      roadSpeed = baseRoadSpeed;

      startBtn.classList.remove('disabled');
      modal.style.display = 'none';
      updateUI();
    }

    function getLaneX(lane) {
      return roadX + lane * laneWidth + (laneWidth - playerWidth) / 2;
    }

    function updateUI() {
      dollarsEl.textContent = `$${Math.floor(dollars)}`;
      kmEl.textContent = `${(distance / 1000).toFixed(1)} km`;
    }

    // === PIXEL VECTOR CARS (TOP-DOWN) ===
    function drawCar(x, y, w, h, color, isPlayer = false) {
      ctx.save();
      ctx.translate(x + w/2, y + h/2);
      
      // Car body (main rectangle)
      ctx.fillStyle = color;
      ctx.fillRect(-w*0.45, -h*0.55, w*0.9, h*1.1);
      
      // Car top (roof)
      ctx.fillStyle = isPlayer ? '#ffd700' : darkenColor(color, 0.7);
      ctx.fillRect(-w*0.35, -h*0.75, w*0.7, h*0.35);
      
      // Windows
      ctx.fillStyle = '#4a90e2';
      ctx.fillRect(-w*0.28, -h*0.65, w*0.15, h*0.15);
      ctx.fillRect(w*0.13, -h*0.65, w*0.15, h*0.15);
      
      // Wheels (4 pixel wheels)
      ctx.fillStyle = '#333';
      const wheelSize = w*0.12;
      ctx.fillRect(-w*0.38, -h*0.35, wheelSize, wheelSize);
      ctx.fillRect(w*0.26, -h*0.35, wheelSize, wheelSize);
      ctx.fillRect(-w*0.38, h*0.15, wheelSize, wheelSize);
      ctx.fillRect(w*0.26, h*0.15, wheelSize, wheelSize);
      
      // Headlights (for player only)
      if (isPlayer) {
        ctx.fillStyle = '#fff';
        ctx.fillRect(w*0.35, -h*0.1, w*0.08, h*0.08);
        ctx.fillRect(w*0.35, h*0.02, w*0.08, h*0.08);
      }
      
      ctx.restore();
    }

    function darkenColor(color, factor) {
      const num = parseInt(color.replace("#", ""), 16);
      const amt = Math.round(2.55 * factor * 100);
      const R = (num >> 16) + amt;
      const G = (num >> 8 & 0x00FF) + amt;
      const B = (num & 0x0000FF) + amt;
      return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);
    }

    // === COINS ===
    function drawCoin(x, y, w, type) {
      ctx.save();
      ctx.translate(x + w/2, y + w/2);
      
      if (type === 'x2') {
        // Gold x2 coin
        const pulse = Math.sin(Date.now() * 0.01) * 0.1 + 1;
        ctx.fillStyle = `hsl(55, 100%, ${60 + pulse*10}%)`;
        ctx.beginPath();
        ctx.arc(0, 0, w/2 * pulse, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#fff';
        ctx.font = `${w*0.6}px 'Press Start 2P'`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('x2', 0, 0);
      } else {
        // Silver /2 coin
        const pulse = Math.sin(Date.now() * 0.015 + Math.PI) * 0.1 + 1;
        ctx.fillStyle = `hsl(0, 0%, ${70 + pulse*10}%)`;
        ctx.beginPath();
        ctx.arc(0, 0, w/2 * pulse, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#333';
        ctx.font = `${w*0.45}px 'Press Start 2P'`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('/2', 0, 0);
      }
      
      ctx.restore();
    }

    // === Controls ===
    canvas.addEventListener('touchstart', e => {
      if (!gameActive) return;
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const half = rect.width / 2;
      const dir = (touch.clientX - rect.left) < half ? -1 : 1;
      movePlayer(dir);
    }, { passive: false });

    canvas.addEventListener('click', e => {
      if (!gameActive) return;
      const rect = canvas.getBoundingClientRect();
      const half = rect.width / 2;
      const dir = (e.clientX - rect.left) < half ? -1 : 1;
      movePlayer(dir);
    });

    function movePlayer(dir) {
      player.targetLane = Math.max(0, Math.min(lanes - 1, player.targetLane + dir));
    }

    // === Buttons ===
    startBtn.addEventListener('click', () => {
      if (gameActive) return;
      gameActive = true;
      startBtn.classList.add('disabled');
      requestAnimationFrame(gameLoop);
    });

    cashoutBtn.addEventListener('click', () => {
      if (!gameActive || dollars === 0) return;
      gameActive = false;
      showModal('CASHOUT');
    });

    okBtn.addEventListener('click', () => {
      modal.style.display = 'none';
      resetGame();
    });

    function showModal(type) {
      const earned = Math.floor(dollars);
      if (type === 'CRASH') {
        resultText.textContent = 'You lost:';
        lostAmountEl.textContent = `-${earned}$`;
        lostAmountEl.style.color = '#f66';
      } else {
        resultText.textContent = 'You earned:';
        lostAmountEl.textContent = `+${earned}$`;
        lostAmountEl.style.color = '#0f0';
      }
      distText.textContent = `Distance: ${(distance / 1000).toFixed(1)} km`;
      modal.style.display = 'block';
    }

    // === Spawn enemy ===
    function spawnEnemy() {
      const lane = Math.floor(Math.random() * lanes);
      if (enemies.some(e => Math.abs(e.y + 160) < 250 && e.lane === lane)) return;

      const colors = ['#ff4444', '#44ff44', '#4444ff', '#ff44ff', '#44ffff'];
      const color = colors[Math.floor(Math.random() * colors.length)];
      
      enemies.push({
        x: getLaneX(lane),
        y: -playerHeight - 80,
        width: playerWidth,
        height: playerHeight,
        lane,
        color
      });
    }

    // === Spawn coin ===
    function spawnCoin() {
      const lane = Math.floor(Math.random() * lanes);
      const type = Math.random() < 0.5 ? 'x2' : '/2';
      
      coins.push({
        x: getLaneX(lane),
        y: -40,
        width: playerWidth * 0.6,
        type,
        lane
      });
    }

    // === Game loop ===
    function gameLoop() {
      if (!gameActive) {
        draw();
        return;
      }

      // Speed increases gradually
      roadSpeed = baseRoadSpeed + distance * 0.001;

      roadOffset = (roadOffset + roadSpeed) % 70;

      // Player movement
      player.x += (getLaneX(player.targetLane) - player.x) * 0.35;

      // Enemy spawn
      spawnTimer++;
      if (spawnTimer >= spawnRate) {
        spawnTimer = 0;
        spawnEnemy();
      }

      // Coin spawn (5-7 per km)
      coinSpawnTimer++;
      if (coinSpawnTimer >= coinSpawnRate) {
        coinSpawnTimer = 0;
        spawnCoin();
      }

      // Update enemies
      enemies = enemies.filter(e => {
        e.y += roadSpeed + 5;
        return e.y < canvas.height + 100;
      });

      // Update coins
      coins = coins.filter(c => {
        c.y += roadSpeed + 5;
        return c.y < canvas.height + 100;
      });

      // Dollars & distance (FASTER)
      dollarAcc += dollarRate * (roadSpeed / baseRoadSpeed);
      if (dollarAcc >= 1) {
        dollars += Math.floor(dollarAcc);
        dollarAcc -= Math.floor(dollarAcc);
      }
      distance += roadSpeed * 0.2;

      // Coin collision
      for (let i = coins.length - 1; i >= 0; i--) {
        const c = coins[i];
        if (
          player.x < c.x + c.width * 0.8 &&
          player.x + player.width * 0.8 > c.x &&
          player.y < c.y + c.width * 0.8 &&
          player.y + player.height * 0.8 > c.y
        ) {
          if (c.type === 'x2') {
            dollars *= 2;
          } else {
            dollars *= 0.5;
          }
          coins.splice(i, 1);
          updateUI();
        }
      }

      // Crash collision
      for (let e of enemies) {
        if (
          player.x < e.x + e.width * 0.85 &&
          player.x + player.width * 0.85 > e.x &&
          player.y < e.y + e.height * 0.85 &&
          player.y + player.height * 0.85 > e.y
        ) {
          gameActive = false;
          setTimeout(() => showModal('CRASH'), 200);
          return;
        }
      }

      updateUI();
      draw();
      requestAnimationFrame(gameLoop);
    }

    // === Render ===
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Background
      ctx.fillStyle = '#0f0f1a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Asphalt
      ctx.fillStyle = '#222';
      ctx.fillRect(roadX, 0, roadWidth, canvas.height);

      // Lane markings (FASTER)
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = Math.max(3, canvas.width * 0.009);
      for (let i = 1; i < lanes; i++) {
        const x = roadX + i * laneWidth;
        ctx.beginPath();
        for (let y = roadOffset - 70; y < canvas.height; y += 70) {
          ctx.moveTo(x, y);
          ctx.lineTo(x, y + 35);
        }
        ctx.stroke();
      }

      // Road edges
      ctx.lineWidth = Math.max(6, canvas.width * 0.014);
      ctx.strokeStyle = '#555';
      ctx.beginPath();
      ctx.moveTo(roadX, 0); ctx.lineTo(roadX, canvas.height);
      ctx.moveTo(roadX + roadWidth, 0); ctx.lineTo(roadX + roadWidth, canvas.height);
      ctx.stroke();

      // Coins
      coins.forEach(c => drawCoin(c.x, c.y, c.width, c.type));

      // Enemies
      enemies.forEach(e => drawCar(e.x, e.y, e.width, e.height, e.color));

      // Player (GOLD)
      drawCar(player.x, player.y, player.width, player.height, '#ffaa00', true);
    }

    // Start game immediately (no images needed)
    initGame();
    requestAnimationFrame(() => draw());
  </script>
</body>
</html>
